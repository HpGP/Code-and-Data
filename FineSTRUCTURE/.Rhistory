'hspSWEuropeEAfricaUSA'="#7FCBFF",
'hspSWEuropeMiscAmerica'="#0096FF",
'hspSahul'='#d5b7ed',#para hpgp
'HpAsia2'="#FFD966",
"hspIndigenous"="#7B4BA0",
"hspEAsia"="#e67409"  #'#FFA651'
))+
scale_color_discrete(name=Populations)+
facet_grid(~factor(Populations,levels=unique(Populations)), scale="free_x",space="free")+
#facet_grid(~factor(Country,levels=unique(Country)), scale="free_x",space="free")+
##repite
#facet_grid(~Country+factor(Populations,levels=unique(Populations)), scale="free_x",space="free")+
##Me gusta este pero repite
#facet_nested(~Country+factor(Populations,levels=unique(Populations)), scale="free",space="free")+
#facet_rep_wrap(~Country+factor(Populations,levels=unique(Populations)),scales="free")+
#medio funciona
#facet_wrap(~factor(Populations,levels=unique(Populations))+Country,scales="free")+
theme(
#plot.title=element_text(size=30, face="bold"),
plot.title =element_blank(),
axis.text.x=element_text(angle=90,size=2,hjust=0.95,vjust=0.5),#,colour = Mash_value), #size=2
#axis.text.x=element_blank(), #Solo activar si no queremos nombres en el eje de las X, y desactivar el anterior
axis.text.y=element_text(size=20),
#axis.text.y=element_blank(),
axis.title.x=element_text(size=25),
#axis.title.x=element_blank(),
axis.title.y=element_text(size=25),
#axis.title.y=element_blank(),
#legend.position = "bottom",
legend.title = element_text(size=20),
legend.key.size = unit(0.50, "lines"),
legend.text = element_text(size =20), #rel(2)),
plot.margin = unit(c(3, 0.1, 0.1, 2), "cm"),
#texto de facet_grid
strip.text.x = element_text(angle=90,size=12),
#strip.background = element_rect(colour="white", fill="white")
)+
#scale_x_continuous(breaks =seq(0, final, by = 5),expand = c(0, 0))+
#scale_x_continuous(breaks=0:nrow(Data.m),expand = c(0,0) )+
# scale_x_continuous(labels = StrainsName )+
scale_x_continuous(breaks =seq(from = min(Data.ordered$No2),
to=max(Data.ordered$No2), by =1),
labels = StrainsName, expand = c(0, 0.5) )+
scale_y_continuous(expand = c(0, 0), limits=c(0, 1))+
theme(
strip.text.x = element_text(size=14),  #14 es lo normal
panel.spacing.y = unit(0,"pt"),
#panel.spacing.x = unit(0,"pt"),
#Activar el de abajo si se quiere una separacion entre cada face_grid
#panel.spacing.x = unit(10,"pt"),
strip.background = element_rect(fill="white", colour="black")
)
#R Show me the plot please
ggsave(filename=OutputFilePlot2,p,dpi=400,width = 1200, height = 200, units = "mm")
#Si sale un warning es por que algunos valores son ceros y es necesario modificarlos al menos con un 0.0000001
#warning(p)
ggsave(filename=OutputFilePlot,p,dpi=400,width = 2400, height = 200, units = "mm",limitsize = FALSE)
Data.ordered <- Data[,c(1:3,7,8,6,5,13,14,10,11,15,17,16,18,12,9,4)] ### <- cagA
View(Data.ordered)
Data.4 <-cbind("No2"=1:nrow(Data.ordered),Data.ordered) #activar este para crear grafico por pais
Data.ordered <- Data.4
Data.ordered
#Tranpose data
#Nota el "X...pos" , puede variar en "pos".
Data.m <-melt(Data.ordered,id.vars=c("No2","Pop","ID","Country"))
#Numbers of ids
final <- nrow(Data)
final
id <-rownames(Data.m)
id
Populations <-Data.m$Pop
Country <-Data.m$Country
StrainsName<-Data.ordered$ID
#StrainsName<-Data.m$ID
StrainsName
Mash_value <- ifelse(Data.ordered$HIGH_Mash.distance == "HIGH", "red", "black")
Mash_value
#making the pretty plot
p <- ggplot(Data.m, aes(x=No2,y=value,fill=variable))  +
labs(title=PrincipalTittlePlot, x="Strains",fill="Key colour")+
geom_bar(stat='identity',width = 0.9)+
scale_fill_manual(values=c( 'HpAfrica2'="#000000",
'hspAfrica1SAfrica'="#D9D9D9",
'hpNEAfrica'="#D9D9D9",
'hspAfrica1WAfrica'="#7F7F7F",
'hspAfrica1NAmerica'="#947145",
'hspAfrica1MiscAmerica'="#B08958",
'hspNEurope'="#d62fae", #para hpgp
'hspSWEurope'="#e6a5d6", #para hpgp
'hspEurasia1'="#E082C9",
'hspEurasia2'="#DB5ABC",
'hspSWEuropeChile'="#aacde3",
'hspSWEuropeEAfricaUSA'="#7FCBFF",
'hspSWEuropeMiscAmerica'="#0096FF",
'hspSahul'='#d5b7ed',#para hpgp
'HpAsia2'="#FFD966",
"hspIndigenous"="#7B4BA0",
"hspEAsia"="#e67409"  #'#FFA651'
))+
scale_color_discrete(name=Populations)+
facet_grid(~factor(Populations,levels=unique(Populations)), scale="free_x",space="free")+
#facet_grid(~factor(Country,levels=unique(Country)), scale="free_x",space="free")+
##repite
#facet_grid(~Country+factor(Populations,levels=unique(Populations)), scale="free_x",space="free")+
##Me gusta este pero repite
#facet_nested(~Country+factor(Populations,levels=unique(Populations)), scale="free",space="free")+
#facet_rep_wrap(~Country+factor(Populations,levels=unique(Populations)),scales="free")+
#medio funciona
#facet_wrap(~factor(Populations,levels=unique(Populations))+Country,scales="free")+
theme(
#plot.title=element_text(size=30, face="bold"),
plot.title =element_blank(),
axis.text.x=element_text(angle=90,size=2,hjust=0.95,vjust=0.5),#,colour = Mash_value), #size=2
#axis.text.x=element_blank(), #Solo activar si no queremos nombres en el eje de las X, y desactivar el anterior
axis.text.y=element_text(size=20),
#axis.text.y=element_blank(),
axis.title.x=element_text(size=25),
#axis.title.x=element_blank(),
axis.title.y=element_text(size=25),
#axis.title.y=element_blank(),
#legend.position = "bottom",
legend.title = element_text(size=20),
legend.key.size = unit(0.50, "lines"),
legend.text = element_text(size =20), #rel(2)),
plot.margin = unit(c(3, 0.1, 0.1, 2), "cm"),
#texto de facet_grid
strip.text.x = element_text(angle=90,size=12),
#strip.background = element_rect(colour="white", fill="white")
)+
#scale_x_continuous(breaks =seq(0, final, by = 5),expand = c(0, 0))+
#scale_x_continuous(breaks=0:nrow(Data.m),expand = c(0,0) )+
# scale_x_continuous(labels = StrainsName )+
scale_x_continuous(breaks =seq(from = min(Data.ordered$No2),
to=max(Data.ordered$No2), by =1),
labels = StrainsName, expand = c(0, 0.5) )+
scale_y_continuous(expand = c(0, 0), limits=c(0, 1))+
theme(
strip.text.x = element_text(size=14),  #14 es lo normal
panel.spacing.y = unit(0,"pt"),
#panel.spacing.x = unit(0,"pt"),
#Activar el de abajo si se quiere una separacion entre cada face_grid
#panel.spacing.x = unit(10,"pt"),
strip.background = element_rect(fill="white", colour="black")
)
#R Show me the plot please
ggsave(filename=OutputFilePlot2,p,dpi=400,width = 1200, height = 200, units = "mm")
#Si sale un warning es por que algunos valores son ceros y es necesario modificarlos al menos con un 0.0000001
#warning(p)
ggsave(filename=OutputFilePlot,p,dpi=400,width = 2400, height = 200, units = "mm",limitsize = FALSE)
data('teengamb', package='faraway')
library(tidyverse)  # ggplot2, tidyr, dplyr
library(emmeans)
install.packages("emmeans")
library(emmeans)
data('teengamb', package='faraway')
library(tidyverse)  # ggplot2, tidyr, dplyr
library(emmeans)
data('teengamb', package='faraway')
data('teengamb')#, package='faraway')
library(tidyverse)  # ggplot2, tidyr, dplyr
library(emmeans)
data('teengamb', package='faraway')
install.packages('faraway', repos='http://cran.us.r-project.org')
data('teengamb', package='faraway')
# Forces R to recognize that 0, 1 are categorical, also
# relabels the levels to something I understand.
teengamb <- teengamb %>% mutate( sex = ifelse( sex==1, 'Female', 'Male') )
View(teengamb)
library(tidyverse)
#---- Importar datos ----
getwd()
Dir <- "/Volumes/GoogleDrive-117994053132722504654/Mi unidad/Scripts/GitHub/Machine-learning_Curso/Dia_3"
setwd(Dir)
getwd()
list.files(Dir)
data <-  read_csv("baboon_gut_microbiota.csv")
data
View(data)
#---- Exploracion inicial ----
dim(data)
colnames(data)
# Funciones de dplyr
count(data, season)
#probablemente tenga dist normal por que son muchos datos
table(data$season)
prop.table(table(data$season))
# Conocer los datos que son unicos
unique(data$Phylum)
count(data,unique(data$Phylum))
# Verificar si dos columnas son identicas
setequal(data$sample, data$SampleID)
# Conocer los datos que son unicos
unique(data$Phylum)
# Conocer los datos que son unicos
lenght(unique(data$Phylum))
# Conocer los datos que son unicos
length(unique(data$Phylum))
# Conocer los datos que son unicos
unique(data$Phylum)
#---- Seleccionar columnas ----
colnames(data)
select(data,SampleID, sex, age)
# Se pueden pasar a un vector
columnV <- c("Order","grpup_size","baboon_id")
select(data, all_of(columnV))
# Se pueden pasar a un vector
columnV <- c("Order","group_size","baboon_id")
select(data, all_of(columnV))
# para eliminar columnas eleigidas
select(data, -all_of(columnV))
#---- Exploracion inicial ----
dim(data)
# Para eliminar columnas eligidas
select(data, -all_of(columnV))
# Seleccionar columnas a partir de un patrón
colnames(data)
data$diet_PC1
select(data,contains(c("PC","pc")))
-select(data,contains(c("PC","pc")))
select(data,-contains(c("PC","pc")))
# seleccionar en funcion del tipo de dato
select(data, where(is.character))
# seleccionar en funcion del tipo de dato
select(data, -where(is.character))
# Seleccionar rango de columnas
select(data,1:10)
#---- Filtrado de las observaciones----
unique(data$sex)
count(data, sex)
filter(data,sex=="F")
unique(data$Phylum)
filter(data,Phylum=="Firmicutes")
filter(data,Phylum=="Firmicutes" | Phylum=="Bacteroidetes")
filter(data,Phylum=="Firmicutes" | Phylum=="Bacteroidetes")
filter(data,Phylum=="Firmicutes" & Phylum=="Bacteroidetes")
unique(data$Phylum)
# Si es la misma variable puede construir un vector
categorias <- c("Firmicutes","Actinobacteria","Euryarchaeota","Bacteroidetes")
filter(data, Phylum %in% categorias)
filter(data, !Phylum %in% categorias) #para no seleccionar lo que esta en categorias
filter(data, !Phylum %in% categorias) #para no seleccionar lo que esta en categorias
# Filtrar variables numericas
filter(data,asv_richness>100 & asv_richness<1000)
# Usando between (incluye el rango, elimina los NAs)
filter(data,between(asv_richness,100,1000))
# Uso de pipes
# Crear un subconjunto de datos en donde se eliminen
# aquellas columnas que contengan pc y que contengan
# la temporada de secas
data %>%
select(-contains(c("PC","pc"))) %>%
filter(season == "dry")
# Uso de pipes
# Crear un subconjunto de datos en donde se eliminen
# aquellas columnas que contengan pc y que contengan
# la temporada de secas
data %>%
select(-contains(c("PC","pc"))) %>%
filter(season == "dry") -> baboon
#----Crear nuevas columnas----
baboon %>%
mutate(asv_richness_nuevo=asv_richness*2) %>%
select(asv_richness_nuevo,asv_richness)
# Crear una variable categorica a partir de una numerica
summary(baboon$group_size)
baboon %>%
mutate(group_size2=ifelse(group_size<50,"small","big")) %>%
select(group_size,group_size2)
baboon %>%
mutate(group_size2 <- ifelse(group_size<50,"small","big")) %>%
select(group_size,group_size2)
# Para mas de dos categorias
baboon %>%
mutate(group_size2=case_when(
group_size <= 30 ~ "small",
between(group_size,31,60)~"median",
group_size > 60 ~ "big"
)) %>%
select(group_size,group_size2)
# Para mas de dos categorias
baboon %>%
mutate(group_size2=case_when(
group_size <= 30 ~ "small",
between(group_size,31,60)~"median",
group_size > 60 ~ "big"
)) %>%
select(group_size,group_size2) -> baboon
#----Ordenar filas----
baboon %>%
select(Phylum,counts) %>%
arrange(Phylum)
View(baboon)
#----Ordenar filas----
data %>%
select(-contains(c("PC","pc"))) %>%
filter(season == "dry") -> baboon
baboon %>%
select(Phylum,counts) %>%
arrange(Phylum)
baboon %>%
select(Phylum,counts) %>%
arrange(Phylum, desc(counts))
save(baboon,file="baboon.RData")
#---- Cambiar formato ----
head(fish_encounters)
# Cambiar a formato ancho
ancho <- pivot_wider(fish_encounters)
# Cambiar a formato ancho
ancho <- pivot_wider(fish_encounters,names_from = station,
values_from = seen)
ancho
View(baboon)
View(baboon)
View(data)
# Cambiar a formato largo
pivot_longer(ancho, cols=-1,names_to = "station", values_to = "seen")
baboon_phy <- baboon %>%
select(baboon_id, Phylum, counts)
baboon_phy
pivot_wider(baboon_phy,names_from = Phylum,values_from = counts)
pivot_wider(baboon_phy,names_from = Phylum,values_from = counts,
values_fn = sum)
baboon_phy <- pivot_wider(baboon_phy,names_from = Phylum,values_from = counts,
values_fn = sum)
#---- Trabajar con NAs ----
is.na(baboon_phy$Firmicutes)
is.na(baboon_phy$Actinobacteria)
sum(is.na(baboon_phy$Actinobacteria))
# Conocer las variables que tienen NAs
colSums(is.na(baboon_phy))
# Se pueden eliminar todas las filas con NAs
drop_na(baboon_phy)
# Rellenar los NAs con valores existentes
baboon_phy
replace_na(baboon_phy,Spyrochaetes,.direction=down)
fill(baboon_phy,Spyrochaetes,.direction=down)
fill(baboon_phy,Spirochaetes,.direction=down)
fill(baboon_phy,Spirochaetes,.direction="down")
fill(baboon_phy,Spirochaetes,.direction="up") #En la columna Spirochaetes, los NA se rellenaron con los valores de arriba
# Replazar con la media de esa variable
replace_na(baboon_phy,replace = list(Spirochaetes=mean(baboon_phy$Spirochaetes)))
# Replazar con la media de esa variable
replace_na(baboon_phy,replace = list(Spirochaetes=mean(baboon_phy$Spirochaetes,
na.rm = T)))
# Remplazar con un solo valor
baboon_phy[is.na(baboon_phy)]<-0
baboon_phy
#----Datasets anidados----
baboon %>%
select(baboon_id, Phylum, counts, sex) %>%
group_by(sex)
#----Datasets anidados----
baboon %>%
select(baboon_id, Phylum, counts, sex) %>%
group_by(sex) %>%
nest(data=c(baboon_id,Phylum,counts))
#----Datasets anidados----
baboon %>%
select(baboon_id, Phylum, counts, sex) %>%
group_by(sex) %>%
nest(data=c(baboon_id,Phylum,counts)) -> anidado
View(anidado)
aninado
anidado
anidado$data
anidado$data[[1]]
# Cheat sheet
# https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf
# https://github.com/rstudio/cheatsheets/blob/main/translations/spanish/purrr_es.pdf
library(broom) #transforma los resultados en una tibble
library(magrittr) #
# Quitar notacion cientifica
options(scipen=99999)
#----Repaso de funciones y ciclos for----
# Crear una funcion que convierta los datos de temperatura de celcius a F
celsius_to_farenheit <- function(x){
(x*1.8)+32
}
#----Repaso de funciones y ciclos for----
# Crear una funcion que convierta los datos de temperatura de celcius a F
celsius_to_farenheit <- function(x){
(x*1.8)+32
}
# Probar funcion
celsius_to_farenheit(27)
# Probar funcion
celsius_to_farenheit(27)
# crear conjunto de datos
datos_temperatura <- sample(25:50,100,replace=T)
datos_temperatura
print(celsius_to_farenheit(i))
for(i in seq_along(datos_temperatura)){
print(celsius_to_farenheit(i))
}
lista_vacia <- list()
for(i in seq_along(datos_temperatura)){
lista_vacia[[i]] <- celsius_to_farenheit(i)
}
lista_vacia
lista_vacia[1]
lista_vacia[[1]
lista_vacia[[1]]
lista_vacia[[1]]
#----purrr----
map(datos_temperatura,celsius_to_farenheit)
# Guardar en vector
map_dbl(datos_temperatura,celsius_to_farenheit)
# Guardar en vector
a<-map_dbl(datos_temperatura,celsius_to_farenheit)
# Pasar una función anonima
map_dbl(datos_temperatura,~{(.x*1.8)+32})
#----purr + dataframe----
# Importar datos
library(lterdatasampler)
luq_streamchem
class(luq_streamchem)
class(luq_streamchem$sample_id)
map_chr(luq_streamchem)
map_chr(luq_streamchem,class)
map_dbl(luq_streamchem,n_distinct)
a <- luq_streamchem
View(a)
#----purr + prueba + dataframe----
luq_streamchem
dim(luq_streamchem)
# preparacion del dataset
# extraer año
luq_streamchem$sample_date <- format(as.Date(luq_streamchem$sample_date,
format="%d/%m/%Y"),"%Y")
luq_streamchem
# Convertirlo a factor
luq_streamchem$sample_date <- factor(luq_streamchem$sample_date)
luq_streamchem
luq_streamchem$sample_date
luq <- luq_streamchem
# Recordatorio de anova de una variable
aov_temp <- aov(luq$temp~luq$sample_date)
summary(aov_temp)
# utilizar datasets aninados
luq %>%
select(-sample_id) %>%
pivot_longer(cols=2:21)
# utilizar datasets aninados
luq %>%
select(-sample_id) %>%
pivot_longer(cols=2:21) %>%
na.omit() %>%
nest(data=c(sample_date,value)) -> luq_nest
luq_nest
View(a)
setwd("~/Library/CloudStorage/GoogleDrive-ziliz130290@gmail.com/Mi unidad/Scripts/GitHub/HpGP/HpGP_paper")
# Read in the R functions, which also calls the needed packages
library("gplots")
source("FinestructureLibrary.R")
# Load output data from fineSTRUCTURE
chunkfile<-"Hp_linked_hap.chunkcounts.out"
mcmcfile<-"Hp_linked_hap_mcmc.xml"
treefile<-"Hp_linked_hap_tree.xml"
source("FinestructureLibrary.R")
setwd("~/Library/CloudStorage/GoogleDrive-ziliz130290@gmail.com/Mi unidad/Scripts/GitHub/HpGP/HpGP_paper/FineSTRUCTURE")
source("FinestructureLibrary.R")
# Load output files from FineSTRUCTURE main command
chunkfile<-"Hp_linked_hap.chunkcounts.out"
mcmcfile<-"Hp_linked_hap_mcmc.xml"
treefile<-"Hp_linked_hap_tree.xml"
#Extract additional files from fineSTRUCTURE
mappopchunkfile<-"Hp.EMlinked.mapstate.csv" # population-by-population chunkcount file for the populations used in the MAP (i.e tree)
meancoincidencefile<-"Hp.EMlinked.meancoincidence.csv" # pairwise coincidence, .i.e. proportion of MCMC files where individuals are found in the same
#Read in the chunkcout file
dataraw<-as.matrix(read.table(chunkfile,row.names=1,header=T,skip=1)) # read in the pairwise coincidence
#Read in the MCMC files
mcmcxml<-xmlTreeParse(mcmcfile) # read into xml format
mcmcdata<-as.data.frame.myres(mcmcxml) # convert this into a data frame
#Read and prepare the tree files
treexml<-xmlTreeParse(treefile) # read the tree as xml format
ttree<-extractTree(treexml) # extract the tree into ape's phylo format
ttree$node.label<-NULL # remove the labels of internal nodes in order not to plot them
tdend<-myapetodend(ttree,factor=1) # convert to dendrogram format
# the MAP state
mapstate<-extractValue(treexml,"Pop") # map state as a finestructure clustering
mapstatelist<-popAsList(mapstate) # and as a list of individuals in populations
popnames<-lapply(mapstatelist,NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
popnamesplot<-lapply(mapstatelist,NameMoreSummary) # a nicer summary of the populations
names(popnames)<-popnamesplot # for nicety only
names(popnamesplot)<-popnamesplot # for nicety only
popdend<-makemydend(tdend,mapstatelist) # use NameSummary to make popdend
popdend<-fixMidpointMembers(popdend) # needed for obscure dendrogram reasons
popdendclear<-makemydend(tdend,mapstatelist,"NameMoreSummary") # use NameMoreSummary to make popdend
popdendclear<-fixMidpointMembers(popdendclear) # needed for obscure dendrogram reasons
# Pairwise coincidences
fullorder<-labels(tdend) # the order according to the tree
mcmcmatrixraw<-as.matrix(read.csv(meancoincidencefile,row.names=1)) # read in the pairwise coincidence file we created earlier
mcmcmatrix<-mcmcmatrixraw[fullorder,fullorder]
mapstatematrix<-groupingAsMatrix(mapstatelist)[fullorder,fullorder] # map state for reference
# Coancestry matrix
datamatrix<-dataraw[fullorder,fullorder]
datamatrix
View(datamatrix)
ids_list <-read.csv (file="ids_colours_list.csv",header=FALSE,sep = ",",check.names = FALSE)
ids_list
colnames(datamatrix)
ids_list
colnames(datamatrix)
rownames(ids_list)
colnames(datamatrix)
rownames(ids_list)
colnames(ids_list)
ids_list$V1
test2 <- datamatrix %>%
left_join(datamatrix, by = c(colnames(datamatrix) = ids_list$V1))
test2 <- datamatrix %>%
left_join(datamatrix, by = colnames(datamatrix) = ids_list$V1))
